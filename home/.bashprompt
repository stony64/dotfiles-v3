#!/usr/bin/env bash
# ------------------------------------------------------------------------------
# FILE:        home/.bashprompt
# VERSION:     3.6.6
# DESCRIPTION: Git-Aware PS1 Prompt with Exit Code & Branch Status
# AUTHOR:      Stony64
# CHANGES:     v3.6.6 - Added idempotency guard, robustified PROMPT_COMMAND
# ------------------------------------------------------------------------------

# ShellCheck configuration
# shellcheck source=/dev/null disable=SC2034

# --- IDEMPOTENCY GUARD --------------------------------------------------------
# Prevents multiple loading and PROMPT_COMMAND duplication
[[ -n "${DF_BASHPROMPT_LOADED:-}" ]] && return 0
readonly DF_BASHPROMPT_LOADED=1

# --- COLOR DEFINITIONS --------------------------------------------------------
# Pure ANSI colors for use in functions (printf)
# No \[ \] here - those are only for PS1 string itself

readonly C_RED='\033[31m'
readonly C_GREEN='\033[32m'
readonly C_BLUE='\033[34m'
readonly C_CYAN='\033[36m'
readonly C_YELLOW='\033[33m'
readonly C_MAGENTA='\033[35m'
readonly C_RESET='\033[0m'

# PS1-masked colors (with \[ \] for proper line wrapping)
readonly P_BLUE='\[\033[34m\]'
readonly P_GREEN='\[\033[32m\]'
readonly P_CYAN='\[\033[36m\]'
readonly P_RED='\[\033[31m\]'
readonly P_RESET='\[\033[0m\]'

# --- GIT STATUS FUNCTION ------------------------------------------------------

# ------------------------------------------------------------------------------
# df_prompt_git
#
# Returns PS1-ready string for current Git repository status.
#
# Components:
#   - Branch name (yellow)
#   - '*' indicator if working tree is dirty (yellow)
#   - Remote tracking branch (cyan)
#   - Ahead/behind counts (magenta +N/-N)
#
# Parameters: None
# Returns: Formatted Git status string, empty if not in Git repo
# ------------------------------------------------------------------------------
df_prompt_git() {
    # Check if inside Git repository
    if ! git rev-parse --is-inside-work-tree >/dev/null 2>&1; then
        return 0
    fi

    local branch
    local dirty=""
    local remote=""
    local indicators=""

    # Get current branch or short SHA
    branch=$(git symbolic-ref --short HEAD 2>/dev/null)
    if [[ -z "$branch" ]]; then
        branch=$(git rev-parse --short HEAD 2>/dev/null)
    fi
    [[ -z "$branch" ]] && return 0

    # Check for uncommitted changes (dirty working tree)
    if ! git diff --quiet 2>/dev/null; then
        dirty="${C_YELLOW}*"
    fi

    # Get upstream tracking information
    local upstream
    upstream=$(git rev-parse --abbrev-ref --symbolic-full-name '@{u}' 2>/dev/null)

    if [[ -n "$upstream" ]]; then
        # Extract remote name (before first /)
        remote=" ${C_CYAN}${upstream%%/*}"

        # Get ahead/behind counts
        local counts
        local ahead
        local behind

        counts=$(git rev-list --left-right --count HEAD..."$upstream" 2>/dev/null)
        if [[ -n "$counts" ]]; then
            read -r ahead behind <<< "$counts"
            [[ ${ahead:-0} -gt 0 ]] && indicators+="${C_MAGENTA}+${ahead}"
            [[ ${behind:-0} -gt 0 ]] && indicators+="${C_MAGENTA}-${behind}"
        fi
    fi

    # Return formatted Git status
    printf ' %s(%s%s%s%s)%s' \
        "${C_RESET}" \
        "${C_YELLOW}${branch}" \
        "${dirty}" \
        "${remote}" \
        "${indicators}" \
        "${C_RESET}"
}

# --- EXIT CODE INDICATOR ------------------------------------------------------

# ------------------------------------------------------------------------------
# set_prompt_exit_code
#
# Updates global EXIT_INDICATOR with last command's exit code.
# Shows red colored exit code if non-zero, empty if zero.
# Called automatically via PROMPT_COMMAND before each prompt.
#
# Parameters: None
# Returns: None
# Side Effects: Sets global EXIT_INDICATOR variable
# ------------------------------------------------------------------------------
set_prompt_exit_code() {
    local last_exit_code=$?

    if [[ $last_exit_code -ne 0 ]]; then
        EXIT_INDICATOR="${C_RED}${last_exit_code}${C_RESET} "
    else
        EXIT_INDICATOR=""
    fi
}

# --- PROMPT_COMMAND SETUP -----------------------------------------------------

# Safely append to PROMPT_COMMAND without duplication
if [[ "${PROMPT_COMMAND:-}" != *"set_prompt_exit_code"* ]]; then
    if [[ -n "${PROMPT_COMMAND:-}" ]]; then
        # Append with semicolon separator
        PROMPT_COMMAND="set_prompt_exit_code; ${PROMPT_COMMAND}"
    else
        PROMPT_COMMAND="set_prompt_exit_code"
    fi
fi
export PROMPT_COMMAND

# --- PS1 CONSTRUCTION ---------------------------------------------------------

# Format: [HH:MM:SS] user@host:path (git:branch*) [exit_code]
# $
#
# Components:
#   - [HH:MM:SS]     : Cyan brackets, blue time
#   - user@host      : Red user, green host
#   - :path          : Blue working directory
#   - (git:branch*)  : Dynamic Git status (yellow branch, dirty indicator)
#   - [exit_code]    : Red exit code if last command failed
#   - $              : Prompt symbol ($ for user, # for root)
#
# Critical: \[ \] wraps all ANSI escape sequences for correct line wrapping
# \$(df_prompt_git) is re-executed on each prompt render
# \${EXIT_INDICATOR} expands dynamically from PROMPT_COMMAND

PS1="${P_CYAN}[${P_BLUE}\t${P_CYAN}] "
PS1+="${P_RED}\u${P_RESET}@${P_GREEN}\h${P_RESET}"
PS1+=":${P_BLUE}\w"
PS1+="\$(df_prompt_git)"
PS1+="\n${P_RESET}\${EXIT_INDICATOR}\$ ${P_RESET}"

export PS1

# --- PS2 (CONTINUATION PROMPT) ------------------------------------------------
# Used for multi-line commands
PS2="${P_CYAN}â†’ ${P_RESET}"
export PS2
