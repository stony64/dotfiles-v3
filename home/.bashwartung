#!/usr/bin/env bash
# ------------------------------------------------------------------------------
# FILE:          .bashwartung
# VERSION:       1.5.0
# DESCRIPTION:   System-Wartung mit Background-Index & Resource-Optimization
# AUTHOR:        Stony64
# ------------------------------------------------------------------------------

# --- 0. INITIALISIERUNG (Standalone Logging) ----------------------------------
if ! command -v df_log_error >/dev/null 2>&1; then
    df_log_error()   { printf '\033[31m[ERR]\033[0m %s\n' "$*" >&2; }
    df_log_success() { printf '\033[32m[OK]\033[0m %s\n' "$*"; }
    df_log_info()    { printf '\033[34m-->\033[0m %s\n' "$*"; }
    df_log_warn()    { printf '\033[33m[!]\033[0m %s\n' "$*"; }
fi

# --- 1. APT HELFER ------------------------------------------------------------
_df_wartung_apt_common() {
    export DEBIAN_FRONTEND=noninteractive

    # Warte-Logik falls APT durch Unattended-Upgrades blockiert ist
    local retry=0
    while fuser /var/lib/apt/lists/lock >/dev/null 2>&1 || fuser /var/lib/dpkg/lock-front-end >/dev/null 2>&1; do
        if (( retry >= 6 )); then
            df_log_error "APT ist dauerhaft blockiert (dpkg lock). Abbruch."
            return 1
        fi
        df_log_warn "APT Lock aktiv (Hintergrund-Update?). Warte 10s... ($((retry+1))/6)"
        sleep 10
        ((retry++))
    done

    df_log_info "APT: Synchronisiere Paketlisten..."
    apt-get update || { df_log_error "apt update fehlgeschlagen"; return 1; }

    df_log_info "APT: Installiere Updates (full-upgrade)..."
    apt-get full-upgrade -y || { df_log_error "apt upgrade fehlgeschlagen"; return 1; }

    df_log_info "APT: Bereinige Cache & alte Pakete..."
    apt-get autoremove -yqq && apt-get autoclean -yqq
}

# --- 2. HAUPTFUNKTION ---------------------------------------------------------
df_wartung_run() {
    local mode="${1:-"quick"}"
    local start_time=$(date +%s)

    printf '\033[1m================================================\033[0m\n'
    df_log_info "System-Wartung: $(hostname) [Mode: ${mode}]"
    printf '\033[1m================================================\033[0m\n\n'

    # Validierung
    [[ "$(uname -s)" != "Linux" ]] && { df_log_error "Nur Linux unterstützt!"; return 1; }
    [[ $EUID -ne 0 ]] && { df_log_error "Root-Rechte erforderlich! (Nutze sudo)"; return 1; }

    # 1. APT Basis-Wartung (Immer)
    _df_wartung_apt_common || return 1

    # 2. HOST-SPEZIFISCH (Proxmox / ZFS)
    if [[ "$HOSTNAME" == *proxmox* || "$HOSTNAME" == *pve* || -d /etc/pve ]]; then
        if command -v pveam >/dev/null 2>&1; then
            df_log_info "Proxmox: Update Appliance Manager..."
            pveam update || df_log_warn "pveam update fehlgeschlagen"
        fi

        # ZFS Scrub: NUR im Full-Mode
        if [[ "$mode" == "--full" ]]; then
            if command -v zpool >/dev/null 2>&1; then
                local pools
                pools=$(zpool list -H -o name)
                for pool in $pools; do
                    if ! zpool status "$pool" | grep -q "scrub in progress"; then
                        df_log_info "ZFS: Starte Integritätsprüfung (Scrub) für $pool..."
                        zpool scrub "$pool"
                        df_log_success "Scrub für $pool im Hintergrund gestartet."
                    else
                        df_log_warn "ZFS: Scrub für $pool läuft bereits."
                    fi
                done
            fi
        else
            df_log_info "ZFS: Scrub übersprungen (Quick-Mode)."
        fi
    fi

    # 3. LOCATE DB (Optimiert)
    if command -v updatedb >/dev/null 2>&1; then
        if [[ "$mode" == "--full" ]]; then
            df_log_info "System: Aktualisiere Locate-Index (Vordergrund)..."
            updatedb && df_log_success "Index aktualisiert."
        else
            df_log_info "System: Starte Locate-Index Update im Hintergrund (Resource-Safe)..."
            # ionice -c 3 sorgt für Idle-I/O-Priorität, nice für niedrige CPU-Last
            nice -n 19 ionice -c 3 updatedb &
            df_log_success "Index-Update läuft im Hintergrund weiter."
        fi
    fi

    # 4. ABSCHLUSS & LOGGING
    local end_time=$(date +%s)
    local duration=$((end_time - start_time))

    df_log_success "=== Wartung beendet (Dauer: ${duration}s) ==="

    # Log-Eintrag schreiben
    local logfile="/var/log/bashwartung.log"
    if [[ -d "$(dirname "$logfile")" ]]; then
        printf "%s | %s | Mode: %s | Duration: %ss\n" \
            "$(date '+%Y-%m-%d %H:%M:%S')" "$(hostname)" "$mode" "$duration" >> "$logfile" 2>/dev/null
    fi

    return 0
}
