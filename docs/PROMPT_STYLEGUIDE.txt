```markdown
# Dotfiles Framework Style-Guide (v3.6.7)

**Rolle:** Senior Systemadministrator / Bash-Architekt
**Ziel:** Produktionsreife Shell-Implementierung mit Fokus auf Security (P0) und Idempotenz (P1)

**Hinweis:**
- ‚ö†Ô∏è Pr√ºfe bei Aktualisierungen immer, ob alle Funktionen vorhanden sind. Abweichungen mitteilen.
- ‚ö†Ô∏è Einheitlicher Kommentarstil/Header gem√§√ü Style-Guide einhalten.
- ‚ö†Ô∏è **Modulversionen NICHT vereinheitlichen** ‚Äì bewusst gewollt (z.B. `.bashrc` kann 3.6.7 sein, `.bashprompt` 3.6.6).

---

## 0. Zielraster (Priorit√§ten)

- **P0 ‚Äì Security & Datenintegrit√§t:** Kein `eval`, sicheres Quoting, `least privilege`
- **P1 ‚Äì Determinismus & Idempotenz:** Wiederholte Aufrufe ‚Üí identisches Ergebnis
- **P2 ‚Äì Fehlermodell & Observability:** Logging via `df_log_*` ‚Üí stderr
- **P3 ‚Äì Wartbarkeit:** Logische Gruppierung, klare Header, ShellCheck-clean

---

## 1. Dateistruktur & Header

**Jede** Framework-Datei folgt **exakt** diesem Template:

```bash
#!/usr/bin/env bash
# ------------------------------------------------------------------------------
# FILE:        <Pfad/Name relativ zu Repo-Root> (z.B. lib/core.sh)
# VERSION:     <X.Y.Z> (3 Komponenten, sync mit DF_PROJECT_VERSION)
# DESCRIPTION: <1-Satz Zweck auf Deutsch>
# AUTHOR:      Stony64
# CHANGES:     <Version> - <Kurze Beschreibung der √Ñnderung>
# ------------------------------------------------------------------------------

set -euo pipefail  # FAIL-FAST Standard
```

### Idempotency Guard (Sourced Modules **PFLICHT**)

```bash
# Verhindert mehrfaches Laden (Performance + Seiteneffekte)
[[ -n "${DF_CORE_LOADED:-}" ]] && return 0
readonly DF_CORE_LOADED=1
```

**Beispiel f√ºr verschiedene Guards:**

```bash
# core.sh
[[ -n "${DF_CORE_LOADED:-}" ]] && return 0
readonly DF_CORE_LOADED=1

# .bashrc
[[ -n "${DF_BASHRC_LOADED:-}" ]] && return 0
readonly DF_BASHRC_LOADED=1

# lib/network.sh
[[ -n "${DF_NETWORK_LOADED:-}" ]] && return 0
readonly DF_NETWORK_LOADED=1
```

---

## 2. Funktions-Definition (Pflicht-Header)

**Jede Funktion** dokumentiert:

```bash
# ------------------------------------------------------------------------------
# backup_dotfiles
# Erstellt timestamped Backup als tar.gz in ~/.dotfiles_backups/
# Parameters: None
# Returns: 0 Erfolg, 1 Fehler
# Side Effects: Erstellt Backup-Verzeichnis, schreibt tar.gz
# ------------------------------------------------------------------------------
backup_dotfiles() {
    local backup_root="${BACKUP_DIR:?}"
    local timestamp
    timestamp=$(date +%Y%m%d_%H%M%S)

    # Implementation...
}
```

### Erweiterte Dokumentation (Optional f√ºr komplexe Funktionen)

```bash
# ------------------------------------------------------------------------------
# df_deploy_file
# Deployed einzelne Dotfile mit Backup-Strategie.
# Idempotent: Wiederholte Aufrufe sicher.
# Parameters:
#   $1 - Source-File (z.B. home/.bashrc)
#   $2 - Target-File (z.B. ~/.bashrc)
# Returns:
#   0 - Erfolg (deployed oder bereits aktuell)
#   1 - Source nicht lesbar
#   2 - Target-Dir nicht schreibbar
# Side Effects:
#   - Erstellt Backup wenn Target existiert
#   - Erstellt Symlink oder Kopie
#   - Schreibt Log-Messages
# Examples:
#   df_deploy_file "home/.bashrc" "$HOME/.bashrc"
#   df_deploy_file "home/.config/mc/ini" "$HOME/.config/mc/ini"
# ------------------------------------------------------------------------------
df_deploy_file() {
    local src="${1:?Source file required}"
    local dst="${2:?Target file required}"

    # Validation
    [[ -r "$src" ]] || {
        df_log_error "Source not readable: $src"
        return 1
    }

    # Implementation...
}
```

---

## 3. Namenskonventionen & Pr√§fixe

| Typ                | Pr√§fix   | Beispiele                          | Verwendung             |
|--------------------|----------|------------------------------------|------------------------|
| **Framework-Core** | `df_`    | `df_log_info`, `df_deploy_file`    | **Exklusiv** Framework |
| **User-Tools**     | Kein     | `backup`, `deploy`, `dctl`, `myip` | Terminal-freundlich    |
| **Globals**        | `DF_`    | `DF_PROJECT_VERSION`, `DF_REPO_ROOT` | Exportiert           |
| **Lokals**         | `lower_` | `local timestamp`, `local src_dir` | `local` am Start       |

**Best Practices:**

```bash
# ‚úÖ RICHTIG: Lokale Variablen gruppiert am Anfang
backup_dotfiles() {
    local backup_root="${BACKUP_DIR:?}"
    local timestamp
    local backup_file

    timestamp=$(date +%Y%m%d_%H%M%S)
    backup_file="${backup_root}/dotfiles_${timestamp}.tar.gz"

    # ...
}

# ‚ùå FALSCH: Variablen verstreut
backup_dotfiles() {
    local backup_root="${BACKUP_DIR:?}"
    # some code...
    local timestamp=$(date +%Y%m%d_%H%M%S)
    # more code...
    local backup_file="${backup_root}/dotfiles_${timestamp}.tar.gz"
}
```

---

## 4. Strukturierung innerhalb der Module

**Logische Gruppierung** mit Block-Headers (80 Zeichen):

```bash
#!/usr/bin/env bash
# ------------------------------------------------------------------------------
# FILE:        dotfilesctl.sh
# VERSION:     3.6.7
# DESCRIPTION: Dotfiles Management Tool
# AUTHOR:      Stony64
# ------------------------------------------------------------------------------

set -euo pipefail

# --- CONFIGURATION ------------------------------------------------------------
readonly DF_REPO_ROOT="${DF_REPO_ROOT:-/opt/dotfiles}"
readonly BACKUP_DIR="${HOME}/.dotfiles_backups"

# --- CORE FUNCTIONS -----------------------------------------------------------
df_deploy_file() {
    # ...
}

df_create_backup() {
    # ...
}

# --- HELPER FUNCTIONS ---------------------------------------------------------
_validate_user() {
    # ...
}

_check_permissions() {
    # ...
}

# --- MAIN EXECUTION -----------------------------------------------------------
main() {
    # ...
}

# Execute if not sourced
if [[ "${BASH_SOURCE}" == "${0}" ]]; then
    main "$@"
fi
```

**Standard-Sections:**

1. **CONFIGURATION** - Konstanten, Pfade, Defaults
2. **CORE FUNCTIONS** - Haupt-Funktionen (public API)
3. **HELPER FUNCTIONS** - Private/interne Funktionen (Pr√§fix `_`)
4. **MAIN EXECUTION** - Entry-Point, Argument-Parsing

---

## 5. Logging & Fehlerbehandlung (P2)

**Exklusiv** `df_log_*` verwenden:

```bash
# Information (Blau)
df_log_info "Deploying from $src_dir..."

# Success (Gr√ºn)
df_log_success "Backup created: $backup_file"

# Error (Rot, nach stderr)
df_log_error "Missing directory: $target_dir" >&2

# Warning (Gelb)
df_log_warn "File exists, creating backup: $file"
```

**Strict Mode:**

```bash
set -euo pipefail  # IMMER am Anfang jeder Datei

# -e: Exit on error
# -u: Exit on undefined variable
# -o pipefail: Exit on pipe failures
```

**Fehler-Handling:**

```bash
# ‚úÖ RICHTIG: Explizites Error-Handling
if ! cp "$src" "$dst" 2>/dev/null; then
    df_log_error "Failed to copy: $src ‚Üí $dst"
    return 1
fi

# ‚úÖ RICHTIG: Command-Substitution mit Fallback
timestamp=$(date +%Y%m%d_%H%M%S 2>/dev/null || echo "unknown")

# ‚ùå FALSCH: Keine Fehler-Behandlung
cp "$src" "$dst"  # Stirbt mit set -e, aber keine Log-Message
```

---

## 6. Security & Idempotenz (P0/P1)

### Security Best Practices

| Regel          | Code                    | Zweck                     |
|----------------|-------------------------|---------------------------|
| **Quoting**    | `"$var"`                | **IMMER!** (Word-Splitting) |
| **Null-Guard** | `${VAR:?}`              | Fail-fast bei unset       |
| **Root-Block** | `[[ $EUID -ne 0 ]]`     | Verhindere Root-Ausf√ºhrung |
| **Root-Check** | `[[ $EUID -eq 0 ]]`     | Require Root              |
| **User-Valid** | `getent passwd "$user"` | System-sichere User-Pr√ºfung |

**Beispiele:**

```bash
# ‚úÖ RICHTIG: Sichere User-Validierung
_validate_user() {
    local target_user="${1:?User required}"

    if ! getent passwd "$target_user" >/dev/null 2>&1; then
        df_log_error "User does not exist: $target_user"
        return 1
    fi

    return 0
}

# ‚úÖ RICHTIG: Root-Required
if [[ $EUID -ne 0 ]]; then
    df_log_error "Root privileges required!"
    df_log_info "Try: sudo $0 $*"
    exit 1
fi

# ‚úÖ RICHTIG: Root-Blocked (f√ºr .bashrc etc.)
[[ $EUID -eq 0 ]] && {
    df_log_error "Do not run as root!"
    return 1
}

# ‚úÖ RICHTIG: Parameter-Validation
deploy_file() {
    local src="${1:?Source file required}"
    local dst="${2:?Target file required}"

    [[ -r "$src" ]] || {
        df_log_error "Source not readable: $src"
        return 1
    }

    # ...
}
```

### Idempotenz

**Timestamped Backups:**

```bash
# ‚úÖ RICHTIG: Idempotent Backup
backup_file() {
    local file="${1:?}"
    local timestamp
    timestamp=$(date +%Y%m%d_%H%M%S)

    if [[ -e "$file" ]]; then
        cp -p "$file" "${file}.bak_${timestamp}"
        df_log_success "Backup: ${file}.bak_${timestamp}"
    fi
}

# ‚ùå FALSCH: Nicht idempotent (√ºberschreibt)
backup_file() {
    cp "$file" "${file}.bak"  # Zweiter Aufruf √ºberschreibt!
}
```

**Symlink-Handling:**

```bash
# ‚úÖ RICHTIG: Idempotent Symlink
create_link() {
    local src="${1:?}"
    local dst="${2:?}"

    # Existiert bereits und zeigt auf richtige Quelle?
    if [[ -L "$dst" ]] && [[ "$(readlink "$dst")" == "$src" ]]; then
        df_log_info "Already linked: $dst ‚Üí $src"
        return 0
    fi

    # Backup bei Konflikt
    if [[ -e "$dst" ]]; then
        local timestamp
        timestamp=$(date +%Y%m%d_%H%M%S)
        mv "$dst" "${dst}.bak_${timestamp}"
        df_log_warn "Moved: $dst ‚Üí ${dst}.bak_${timestamp}"
    fi

    # Link erstellen
    ln -sf "$src" "$dst"
    df_log_success "Linked: $dst ‚Üí $src"
}
```

---

## 7. Best-Practice Beispiele

### 7.1 Module Loader (Deterministic)

```bash
# ------------------------------------------------------------------------------
# load_modules
# L√§dt Framework-Module in fester Reihenfolge.
# Idempotent: Mehrfaches Laden sicher durch Module-Guards.
# Parameters: None
# Returns: 0 Erfolg, 1 bei kritischen Fehlern
# Side Effects: Sourced Module-Dateien
# ------------------------------------------------------------------------------
load_modules() {
    local -a modules=(
        ".bashenv"
        ".bashfunctions"
        ".bashaliases"
        ".bashprompt"
        ".bashwartung"
    )

    local mod_name
    local mod_path

    for mod_name in "${modules[@]}"; do
        mod_path="${HOME}/${mod_name}"

        if [[ -r "$mod_path" ]]; then
            # shellcheck source=/dev/null
            if ! source "$mod_path"; then
                df_log_warn "Failed to load: $mod_name"
            fi
        else
            # Silent skip f√ºr optionale Module
            :
        fi
    done

    return 0
}
```

### 7.2 Symlink Creation (Idempotent)

```bash
# ------------------------------------------------------------------------------
# create_link
# Erstellt Symlink mit Backup-Strategie.
# Idempotent: Wiederholte Aufrufe sicher.
# Parameters:
#   $1 - Source (absoluter Pfad)
#   $2 - Target (Symlink-Pfad)
# Returns: 0 Erfolg, 1 Fehler
# Side Effects: Erstellt Symlink, ggf. Backup
# Examples:
#   create_link "/opt/dotfiles/home/.bashrc" "$HOME/.bashrc"
# ------------------------------------------------------------------------------
create_link() {
    local src="${1:?Source required}"
    local dst="${2:?Target required}"
    local timestamp

    # Validierung
    if [[ ! -e "$src" ]]; then
        df_log_error "Source does not exist: $src"
        return 1
    fi

    # Bereits korrekt gelinkt?
    if [[ -L "$dst" ]] && [[ "$(readlink "$dst")" == "$src" ]]; then
        df_log_info "Already linked: $dst ‚Üí $src"
        return 0
    fi

    # Target-Dir erstellen falls n√∂tig
    local target_dir
    target_dir=$(dirname "$dst")
    if [[ ! -d "$target_dir" ]]; then
        mkdir -p "$target_dir" || {
            df_log_error "Cannot create directory: $target_dir"
            return 1
        }
    fi

    # Backup bei Konflikt
    if [[ -e "$dst" ]] || [[ -L "$dst" ]]; then
        timestamp=$(date +%Y%m%d_%H%M%S)
        mv "$dst" "${dst}.bak_${timestamp}" || {
            df_log_error "Cannot backup: $dst"
            return 1
        }
        df_log_warn "Backed up: $dst ‚Üí ${dst}.bak_${timestamp}"
    fi

    # Symlink erstellen
    if ln -sf "$src" "$dst"; then
        df_log_success "Linked: $dst ‚Üí $src"
        return 0
    else
        df_log_error "Failed to link: $dst ‚Üí $src"
        return 1
    fi
}
```

### 7.3 User Input Validation

```bash
# ------------------------------------------------------------------------------
# validate_user
# Validiert User-Existenz √ºber getent (system-safe).
# Parameters:
#   $1 - Username
# Returns: 0 wenn User existiert, 1 sonst
# ------------------------------------------------------------------------------
validate_user() {
    local username="${1:?Username required}"

    if ! getent passwd "$username" >/dev/null 2>&1; then
        df_log_error "User does not exist: $username"
        return 1
    fi

    df_log_info "User validated: $username"
    return 0
}
```

### 7.4 File Deployment (Robust)

```bash
# ------------------------------------------------------------------------------
# deploy_file
# Deployed einzelne Dotfile mit Backup-Strategie.
# Idempotent: Pr√ºft Checksum vor Kopieren.
# Parameters:
#   $1 - Source file
#   $2 - Target file
# Returns: 0 Erfolg, 1 Fehler
# Side Effects: Erstellt Backup, kopiert Datei
# ------------------------------------------------------------------------------
deploy_file() {
    local src="${1:?Source required}"
    local dst="${2:?Target required}"
    local timestamp

    # Source validieren
    [[ -r "$src" ]] || {
        df_log_error "Source not readable: $src"
        return 1
    }

    # Bereits identisch?
    if [[ -f "$dst" ]] && cmp -s "$src" "$dst"; then
        df_log_info "Already up-to-date: $dst"
        return 0
    fi

    # Target-Dir erstellen
    local target_dir
    target_dir=$(dirname "$dst")
    mkdir -p "$target_dir" || {
        df_log_error "Cannot create directory: $target_dir"
        return 1
    }

    # Backup bei √Ñnderung
    if [[ -e "$dst" ]]; then
        timestamp=$(date +%Y%m%d_%H%M%S)
        cp -p "$dst" "${dst}.bak_${timestamp}" || {
            df_log_error "Backup failed: $dst"
            return 1
        }
        df_log_warn "Backed up: ${dst}.bak_${timestamp}"
    fi

    # Datei kopieren (Permissions beibehalten)
    if cp -p "$src" "$dst"; then
        df_log_success "Deployed: $dst"
        return 0
    else
        df_log_error "Deploy failed: $src ‚Üí $dst"
        return 1
    fi
}
```

---

## 8. Qualit√§tssicherung

| Tool               | Status     | Config                      |
|--------------------|------------|-----------------------------|
| **ShellCheck**     | 0 Warnings | `.shellcheckrc`             |
| **markdownlint**   | SARIF      | `.markdownlint-cli2.jsonc`  |
| **EditorConfig**   | Enforced   | `.editorconfig`             |

### ShellCheck Disables (nur wenn n√∂tig)

```bash
# ‚úÖ RICHTIG: Begr√ºndet
# shellcheck disable=SC1073  # MC INI: [Section] syntax intentional
# shellcheck disable=SC2034  # Exported vars used by child scripts

# ‚ùå FALSCH: Zu breit
# shellcheck disable=SC1090,SC2086,SC2155  # Zu viele Codes!
```

### Coding Standards

- **Indentation:** 4 Spaces (Bash/Shell), 2 Spaces (YAML/JSON)
- **Line Length:** 120 Zeichen (empfohlen 78-100)
- **Rulers:** 78, 120 (in VS Code)
- **Encoding:** UTF-8
- **Line Endings:** LF (`\n`)
- **Final Newline:** Ja

---

## 9. Testing & Validation

### Pre-Commit Checklist

```bash
# 1. ShellCheck
shellcheck -x dotfilesctl.sh core.sh lib/*.sh

# 2. Markdown Lint
markdownlint-cli2 --fix "**/*.md"

# 3. Syntax Check
bash -n dotfilesctl.sh

# 4. Test Execution (Dry-Run)
./dotfilesctl.sh --dry-run status
```

### CI/CD Workflow

```yaml
# .github/workflows/lint.yml
- name: ShellCheck
  run: shellcheck -x **/*.sh

- name: Markdown Lint
  uses: DavidAnson/markdownlint-cli2-action@v20
  with:
    config: .markdownlint-cli2.jsonc
    fix: false
```

---

## 10. Anti-Patterns (Vermeiden!)

```bash
# ‚ùå FALSCH: eval (Security Risk)
eval "$(some_command)"

# ‚úÖ RICHTIG: Direkt ausf√ºhren
source <(some_command)

# ‚ùå FALSCH: Unquoted Variables
rm -rf $HOME/tmp/*

# ‚úÖ RICHTIG: Quoted
rm -rf "${HOME}/tmp/"*

# ‚ùå FALSCH: Globale Variablen ohne readonly
PROJECT_VERSION="3.6.7"

# ‚úÖ RICHTIG: readonly f√ºr Konstanten
readonly DF_PROJECT_VERSION="3.6.7"

# ‚ùå FALSCH: Pipes mit Variablen
cat $file | grep pattern

# ‚úÖ RICHTIG: Direct Input
grep pattern "$file"

# ‚ùå FALSCH: Command Substitution ohne Error-Handling
timestamp=$(date +%Y%m%d)

# ‚úÖ RICHTIG: Mit Fallback
timestamp=$(date +%Y%m%d 2>/dev/null || echo "unknown")
```

---

## 11. Changelog

| Version | Datum | √Ñnderungen |
|---------|-------|------------|
| **3.6.7** | 2026-02-16 | Added examples for `load_modules()` and `create_link()` |
| 1.5.1 | 2026-02-15 | Initial documented version |

---

**Maintained by:** Stony64
**Last Update:** 2026-02-16
**Framework Version:** 3.6.7
```

***

## üéØ √ÑNDERUNGEN v1.5.1 ‚Üí v3.6.7

### ‚úÖ **1. Version-Bump f√ºr Framework-Konsistenz**
```diff
- # Dotfiles Framework Style-Guide (v1.5.1) ##
+ # Dotfiles Framework Style-Guide (v3.6.7)
```

***

### ‚úÖ **2. NEUE SECTION: Best-Practice Beispiele (7.)**

#### **A) load_modules() - Deterministic Module Loading**
```bash
# L√§dt Module in fester Reihenfolge
# Idempotent durch Module-Guards
# Fehlertoleranz (continue on non-critical errors)
```

#### **B) create_link() - Idempotent Symlink Creation**
```bash
# Pr√ºft ob bereits korrekt gelinkt
# Erstellt Timestamped Backups
# Target-Dir wird automatisch erstellt
# Vollst√§ndiges Error-Handling
```

#### **C) validate_user() - System-Safe User Validation**
```bash
# Verwendet getent (nicht /etc/passwd)
# Funktioniert mit LDAP/AD
```

#### **D) deploy_file() - Robust File Deployment**
```bash
# Checksum-Vergleich vor Kopieren
# Timestamped Backups
# Permissions-Erhaltung
```

***

### ‚úÖ **3. Erweiterte Funktions-Dokumentation**
```bash
# Vorher:
# ------------------------------------------------------------------------------
# backup_dotfiles
# Erstellt timestamped Backup ‚Üí tar.gz in ~/.dotfiles_backups/
# RETURN: 0 Erfolg, 1 Fehler
# ------------------------------------------------------------------------------

# Nachher:
# ------------------------------------------------------------------------------
# backup_dotfiles
#
# Erstellt timestamped Backup als tar.gz in ~/.dotfiles_backups/
#
# Parameters: None
# Returns: 0 Erfolg, 1 Fehler
# Side Effects: Erstellt Backup-Verzeichnis, schreibt tar.gz
# ------------------------------------------------------------------------------
```

***

### ‚úÖ **4. Erweiterte Security-Beispiele**
```bash
# Root-Required
# Root-Blocked
# User-Validation mit getent
# Parameter-Validation
```

***

### ‚úÖ **5. Idempotenz-Beispiele**
```bash
# Timestamped Backups
# Symlink-Checking
# Checksum-Vergleich
```

***

### ‚úÖ **6. Neue Section: Anti-Patterns (10.)**
```bash
# Konkrete "Falsch vs. Richtig" Beispiele
# eval, unquoted vars, useless cat, etc.
```

***

### ‚úÖ **7. Neue Section: Testing & Validation (9.)**
```bash
# Pre-Commit Checklist
# CI/CD Workflow Beispiel
```

***

### ‚úÖ **8. Changelog Section (11.)**
```markdown
| Version | Datum | √Ñnderungen |
|---------|-------|------------|
| **3.6.7** | 2026-02-16 | Added examples for load_modules() and create_link() |
| 1.5.1 | 2026-02-15 | Initial documented version |
```

***
